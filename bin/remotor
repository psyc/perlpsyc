#!/usr/bin/perl -I/usr/depot/lib/perl5
#
# remote control for Tor: the remoTor!
#	--symlynX 2016
#
# + produce and receive Tor events over the ControlPort
# + forward important messages into a chatroom via PSYC
# + interact with the user over the terminal console

my $host = '127.0.0.1';	    # defaults to try
my $port = 9051;
my $circ = 1;		    # request real-time circuit activity by default?

sub version() { "1.2" }

#  0: all debug statements will be optimized away by the perl compiler
#  1: debug Tor control
#  2: debug STDIN
#  4: debug PSYC
#  8: debug Tor log socket
# 16: debug config parsing
# 63: full debugging
sub debug() { 0 }

# if PSYC is enabled, should remotor really join the chatroom,
# thus receive ongoing chat directly rather than just manually?
sub chat() { 1 }

use IO::Socket::INET;
use POSIX qw( mkfifo );			# optional, for -s option
use Term::ANSIColor qw( :constants );	# optional but pervasive
use Net::PSYC qw( :event );		# needed for event loop
use Getopt::Std;
getopt('bcilmpstHP');

my $bind = $opt_b || "psyc://$ENV{USER}\@127.0.0.1:4051/\$remotor";
my $ini = $opt_c || "$ENV{HOME}/.tor/remotor.ini";
my $torlog = $opt_s || "/var/run/tor/log.sock";

my $torsock = undef;
my $logsock = undef;
my $target;
my $log = undef;
my %config;
my %pv;


## SANDWICHES ##

sub say {
	print BOLD, GREEN, @_, RESET, "\n";
}

sub reallyquit { exit; }
sub quit {
	tellpsyc(chat? "_request_leave_remotor": "_notice_stopping_remotor", "[_command] stopping on [_nick].");
	add(1, 't', \&reallyquit);
}

sub tellpsyc {
	my ($mc, $text) = @_;
	say "tellpsyc: ", $text if debug & 4;
	sendmsg($target, $mc, $text, \%pv) if $target;
}

sub terror {
	my $msg = "Error on the Tor control socket. $_";
	say $msg;
	tellpsyc('_warning_remotor', $msg);
	return &quit;
}

sub torparse {
	$_ = <$torsock>;
	say "torparse($!): $_" if debug & 1;
	chop; chomp;
	terror unless $_;
	return if $_ eq '510 Unrecognized command ""';
	# we're not vidalia.. let's just show built circuits
	return if /^650 CIRC \d+ (LAUNCHED|EXTENDED)/;
	s/ TIME_CREATED=\S+\b//;    # too much information
	s/ SOCKS_PASSWORD="0"//;    # not interesting
	s/ PURPOSE=GENERAL\b//;	    # only show ungeneral purposes
	s/\bPURPOSE=(\S+)\b/ GREEN. $1 .RESET /e;
	s/\bBUILD_FLAGS=(\S+)\b/ BLUE. $1 .RESET /e;
	s/\bREND_QUERY=(\S+)\b/ CYAN. $1 .RESET /e;
	s/\bHS_STATE=\b//;
	# let it be human readable
	s/IS_INTERNAL\b/i/;
	s/ONEHOP_TUNNEL\b/o/;
	s/NEED_CAPACITY\b/c/;
	s/NEED_UPTIME\b/u/;
	s/\$\w+~(\w+)\b/ MAGENTA. $1 .RESET /ge;
	print YELLOW, $_, RESET, "\n";
	tellpsyc('_warning_remotor', $_) if
	    /(FAIL|ERROR|DESTROY|SIGNAL|DANGER|LIVENESS|HIBERNATION|TRANSPORT|GUARD|BAD|HIJACKED|USELESS|UNREACHABLE|CLOCK|BUG|TOO_MANY)\b/;
	print $log "> $_\n" if $log;
	print $torsock "\n";
}

sub torlogparse {
	$_ = <$logsock>;
	chop; chomp;
	if ( / \[debug\] / ) {
		return unless / \{APP\} connection_ap_handshake_rewrite... Client asked for (\S+)$/;
		print CYAN, "Request for $1", RESET, "\n";
		tellpsyc('_notice_remotor_monitor', $1) if $opt_f;
		return;
	} elsif ( / \[info\] / ) {
		say "torlogparse: $_" if debug & 8;
		return;
	}
	say $_;
}

sub keyparse {
	$_ = <STDIN>;
	say "keyparse: ", $_ if debug & 2;
	return &quit if /^\s*q\s*$/i;
		# should be _converse
	return tellpsyc("_message_public", $1) if m!^\s*/\s+(.*\S.*)$!;
	return unless $torsock;
	return &circtoggle if /^\s*t\s*$/i;
	s/^\s*n\s*$/SIGNAL NEWNYM\n/i;
	s/^\s*c\s*$/GETINFO circuit-status\n/i;
	s/^\s*s\s*$/GETINFO stream-status\n/i;
	s/^\s*g\s*$/GETINFO entry-guards\n/i;
	if ( /^\s*(\S|help)\s*$/i ) {
		print <<X;
	*** Available shortcuts:
	    'q'		to quit
	    'n'		for a new identity
	    'c'		to see the circuit-status
	    's'		to see the stream-status
	    't'		to toggle delivery of circuit events
	    'g'		for the list of entry guards
	    '/ <msg>'	to send a message to the PSYC channel
X
		return;
	}
	print $torsock $_;
	print $log "<<< $_" if $log;
}

sub circtoggle {
	my $c = "SETEVENTS STATUS_CLIENT STATUS_GENERAL STATUS_SERVER";
	$c .= " CIRC" if $circ;	    # CIRC is pretty verbose
	print $torsock $c, "\n";
	$circ = 1 - $circ;
}

sub msg {
	my ($source, $mc, $data, $vars) = @_;
	say "psyc: $mc from $source" if debug & 4;
	if ($mc =~ /^_(message|converse)/) {
		# message echo will pass through here. legitimate users of
		# your PSYC server can send a message back to the localhost
		# process, so you may see an answer from somebody.
		if (exists $vars->{_nick}) {
			$_ = "<". $vars->{_nick} ."> ". $data;
		} else {
			$_ = "(". $source ."> ". $data;
		}
	} else {
		$_ = psyctext($data, $vars);
	}
	print BOLD, MAGENTA, $_, RESET, "\n";
}

# simple .ini file format parser taken from psyconf
sub iniparse {
	my $cf = shift;
	my $f = "default";
	open C, $cf;
	while(<C>) {
		next if /^;/;
		next if /^\s*$/;
		$f = $1, next if /^\[(\w+)\]\s*$/;
		$config{"$f:$1"} = $2, next
		    if /^(\w+)\s*=\s*(.+?)\s*$/;
		die "cannot parse line $. in $cf\n\t$_\n";
	}
	close C;
	say join ' ', keys %config if debug & 16;
}

sub idlebilly {
	print $torsock "GETINFO stream-status\n";
}


## MAIN ###

	say "remoTor ", version, " - a control console for Tor routers with PSYC notification";
	$|=1;
	&iniparse($ini);
	my $nick = shift || 'default';
	$host = $1 if $ENV{http_proxy} =~ m!^http://(\S+):\d+$!;
	$host = $1 if $ENV{HTTP_PROXY} =~ m!^http://(\S+):\d+$!;
	$host = $1 if $ENV{SOCKS_PROXY} =~ m!^socks://(\S+):\d+$!;
	$host = $config{"$nick:host"} if $config{"$nick:host"};
	$port = $config{"$nick:port"} if $config{"$nick:port"};
	my $auth = $config{"$nick:auth"};
	$auth = $opt_p if $opt_p;
	$host = $opt_H if $opt_H;
	$port = $opt_P if $opt_P;
	$target = $opt_t || $config{"$nick:notify"}
			 || $config{"default:notify"};

	if ($opt_s and not -p $torlog) {
		undef $!;
		die "Could not mkfifo $torlog: $!" unless mkfifo $torlog, 0600;
		system('chgrp', 'tor', $torlog) and chmod 0660, $torlog;
	} elsif (not -p $torlog) {
		undef $torlog;
	}
	if ($torlog) {
		open($logsock, $torlog) or die "Cannot read from $torlog: $!";
		add($logsock, 'r', \&torlogparse);
	}

	die <<X unless $auth or $torlog;
Is $host:$port the host and port your Tor router answers on?

Usage: $0 [<options>] [<nickname>]

Options:
	-p <password>	Authentication string needed to take control
	-H <host>	Tor router host
	-P <port>	Tor router control port
	-l <logfile>	Keep a transaction log
	-i <seconds>	Request a stream status if idle for a while
	-s <socket>	Scan a Tor logging socket for interesting events
	-f		Forward circuit creation requests to PSYC
	-c <config>	Alternate configuration file to use
	-t <uniform>	PSYC address to send notifications to
	-b <uniform>	PSYC address to bind to

<nickname> matches an entry from the $ini file.
Here's an example for the ini syntax in use:

[default]
host=192.168.0.1
port=9051
auth=somesecretrandomstring
notify=psyc://127.0.0.1/\@remotor

The configuration file is a safer place to store authentication
strings than the command line which can be read by other users
of this computing device (in case you have any). The default
entry will be used unless you specify a nickname.
X
	if ($auth) {
		say "Trying to connect Tor router at $host:$port";
		$torsock = IO::Socket::INET->new( Proto => 'tcp',
						  PeerAddr => $host,
						  PeerPort => $port);
		die "Could not connect to $host:$port: $!" unless $torsock;
		say "Connected to ControlPort at $host:$port";

		bind_uniform( $bind );
		register_uniform();
		say "Listening for PSYC controls on $bind";
		print GREEN, "Taking Tor commands from STDIN. Type '?' for a list of shortcuts.\n", RESET;
		print GREEN, "See also https://gitweb.torproject.org/torspec.git/plain/control-spec.txt\n", RESET;

		print $torsock <<X;
AUTHENTICATE "$auth"
USEFEATURE EXTENDED_EVENTS VERBOSE_NAMES
GETINFO stream-status
X
		&circtoggle;
		add($torsock, 'r', \&torparse);
		add($torsock, 'e', \&terror);
	}
	die "Cannot write to $opt_l: $!"
	    if $opt_l and not open($log, '>>', $opt_l);
	print $log "\n\n\n\n\n*** New session ***\n\n" if $log;

	add(\*STDIN, 'r', \&keyparse);
	add($opt_i, 'i', \&idlebilly) if $opt_i;
	$pv{_nick} = $nick;
	$pv{_command} = $0;
	tellpsyc(chat? "_request_enter_remotor": "_notice_starting_remotor", "[_command] starting on [_nick].");
	start_loop();
	exit;

