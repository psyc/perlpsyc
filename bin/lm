#!/usr/bin/perl
    eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
	if $running_under_some_shell;

# a cool way to list mpeg files, especially for grepping.	-lynx
#
# commands:
# 	-l(ocate) = use locate to find all mp3s on this computer
# 	-i(ndex) = use hostname-based presets
#	-z for optimized indexing of non-mpeg files
#	-p(ath only) = only output files with path, for .m3u creation
#
# options:
# 	-c(drom) = cd to /cdrom before starting
# 	-h(ypertext) = produce HTML output
# 	-x(clusive) = ignore all non-mpeg files
# 	-E(mpty) = skip empty files
#	-q(uiet) = no progress output
#	-n(link) = show the number of links of each file
# 	-v(erbose)
# 	-D(elete) = CAUTION! deletes all mp3s of 'L' low quality
#	-b(itrate) <minimum> = output only things of minimum bitrate
#	-L(ist) = output just a simple list of filenames (use with -b)
#
# leading '--- ' in filenames can be a dealbreaker for lm. this helps:
#	rename 's:^[ -]+::' *

use MP3::List;
my $sumTime = 0;

main: {
	require 'find.pl';

	# most unices do it wrong, apparently
	$File::Find::dont_use_nlink = 'DONT!';

	if ($#ARGV >= 0) {
                require 'getopt.pl';
                &Getopt('b');
		chdir ('/cdrom') if $opt_c;
		goto locate if $opt_l;
		if ($opt_i) {
			my $label = shift || $ENV{HOST};
			goto uc($label);
		}
	}
	goto end;
FLY:	;
	; # fall thru
locate:
	&find(grep(/\.mp3$/, split(/\n/,
		   `/usr/bin/locate \.mp3`)));
	&find(@ARGV) if @ARGV;
	goto summary;
MUZE:
	$opt_n++;
	push @ARGV, '/i/muze';
	goto end;
ARTY:
	$opt_n++;
	push @ARGV, '/i/arty';
	goto end;
GROTTA:
	push @ARGV, '/fat/Eigene Dateien/mp3';
	goto end;
LEECH:
	# it doesn't follow symlinks..
	push @ARGV, '/fat/LoCAL', '/thin/LoCAL';
	goto end;
DRUMPAD:    ;
SLIME:
	push @ARGV, '/fat/LoCAL', '/thin/LoCAL';
	goto end;
KLOTZ:
	push @ARGV, '/fat/';
	# fall thru
end:
	&find(@ARGV ? @ARGV : '.');
	# fall thru
summary:
	print STDERR "\n" unless $opt_q;
	if ($sumTime) {
		my $SS = int $sumTime % 60;
		my $M2 = int $sumTime / 60;
		my $HH = int $M2 / 60;
		my $MM = int $M2 % 60;
		printf "TOTAL\t%5d:%.2d  (= %.2d:%.2d:%.2d)\r\n",
		    $M2,$SS, $HH,$MM,$SS;
	}
}

#%already_seen = ();

sub progress {
	return if $opt_q;
	my $tx = join('', @_);
	my $len = length $tx;
	$tx = "...". substr($tx, length($tx)-73) if $len > 75;
	unless ($opt_q) {
		print STDERR "\r", $tx, ' ', '_' x (75-$len), ' ' if $len < 75;
#		print "\n" if DEBUG & 1;
	}
}

sub wanted {
	# strange ntfs problems apparently.. this is needed to index slime's ntfs
#	if ($opt_x and /\b(RECYCLER|VOLATILE|avp\.fi|fuckyuo|tetsuo)\b/i) {
##	if ($opt_x and /\b(RECYCLER|VOLATILE|Audio_Archive|grotta_\w+|leech_\w+|slime_\w+)\b/i) {
##		print STDERR "\r[pruning $name]\n";
##		return $prune = 1
##	}
	progress($name);
	# strange ntfs problems apparently.. this is needed to index slime's ntfs
#	return if /^(Ober_Control_-_I_v_been_told|Austrofred|tony.telex)/;
	my ($out, $dur) = &MP3::List::format($_, $name, $opt_z, $opt_x, $opt_v,
		$opt_h, $opt_D, $opt_p, $opt_E, $opt_n, $opt_b, $opt_L);
	if ($out) {
		$sumTime += $dur;
		print $out;
	}
}

