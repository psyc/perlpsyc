#!/usr/bin/perl -I/usr/depot/lib/perlxt

# a cool way to list mpeg files, especially for grepping.	-lynx
#
# leading '--- ' in filenames can be a dealbreaker for lm. this helps:
#	rename 's:^[ -]+::' *

use MP3::List;
use Getopt::Std;
use File::Find ();

my $sumTime = 0;

main: {
	if ($#ARGV >= 0) {
                getopt('bsc');
		if ($opt_h) { print <<X; exit; }
Usage: $0 <commands> <options> <arguments>

Commands:
    -l(ocate) = use locate to find all mp3s on this computer
    -i(ndex) = use hostname-based presets
    -z for optimized indexing of non-mpeg files
    -p(ath only) = only output files with path, for .m3u creation

Options:
    -c(hdir) <where> = chdir to <where> before starting
    -H(ypertext) = produce HTML output
    -x(clusive) = ignore all non-mpeg files
    -s(ize) <value> = skip files smaller than value (default is 1234)
    -q(uiet) = no progress output
    -n(link) = show the number of links of each file
    -v(erbose)
    -V(erbose) = show file scan progress on STDERR
    -D(elete) = CAUTION! deletes all mp3s of 'L' low quality
    -b(itrate) <minimum> = output only things of minimum bitrate
    -L(ist) = output just a simple list of filenames (use with -b)
X
		chdir ($opt_c) if $opt_c;
		goto locate if $opt_l;
		if ($opt_i) {
			my $label = shift || $ENV{HOST};
			goto uc($label);
		}
	}
	goto end;
FLY:	;
	; # fall thru
locate:
	&File::Find::find(\&wanted, grep(/\.mp3$/, split(/\n/,
		   `/usr/bin/locate \.mp3`)));
	&File::Find::find(\&wanted, @ARGV) if @ARGV;
	goto summary;
MUZE:
	$opt_n++;
	push @ARGV, '/i/muze';
	goto end;
GROTTA:
	push @ARGV, '/fat/Eigene Dateien/mp3';
	goto end;
LEECH:
	# it doesn't follow symlinks..
	push @ARGV, '/fat/LoCAL', '/thin/LoCAL';
	goto end;
ACCROCCO:    ;
DRUMPAD:    ;
SLIME:
	push @ARGV, '/fat/LoCAL', '/thin/LoCAL', '/C';
	goto end;
KLOTZ:
	push @ARGV, '/fat/';
	# fall thru
end:
	&File::Find::find(\&wanted, @ARGV ? @ARGV : '.');
	# fall thru
summary:
	print STDERR "\n" unless $opt_q;
	if ($sumTime) {
		my $SS = int $sumTime % 60;
		my $M2 = int $sumTime / 60;
		my $HH = int $M2 / 60;
		my $MM = int $M2 % 60;
		printf "TOTAL\t%5d:%.2d  (= %.2d:%.2d:%.2d)\r\n",
		    $M2,$SS, $HH,$MM,$SS;
	}
}

#%already_seen = ();

sub progress {
	return if $opt_q;
	my $tx = join('', @_);
	my $len = length $tx;
	$tx = "...". substr($tx, length($tx)-73) if $len > 75;
	if ($opt_V) {
		print STDERR "\r", $tx, ' ', '_' x (75-$len), ' ' if $len < 75;
#		print "\n" if DEBUG & 1;
	}
}

sub wanted {
	my $name = $File::Find::name;
	# strange ntfs problems apparently.. this is needed to index slime's ntfs
#	if ($opt_x and /\b(RECYCLER|VOLATILE|avp\.fi|fuckyuo|tetsuo)\b/i) {
##	if ($opt_x and /\b(RECYCLER|VOLATILE|Audio_Archive|grotta_\w+|leech_\w+|slime_\w+)\b/i) {
##		print STDERR "\r[pruning $name]\n";
##		return $prune = 1
##	}
	progress($name);
	# strange ntfs problems apparently.. this is needed to index slime's ntfs
#	return if /^(Ober_Control_-_I_v_been_told|Austrofred|tony.telex)/;
	my ($out, $dur) = &MP3::List::format($_, $name, $opt_z, $opt_x, $opt_v,
		$opt_H, $opt_D, $opt_p, $opt_s, $opt_n, $opt_b, $opt_L);
	if ($out) {
		$sumTime += $dur;
		print $out;
	}
}

